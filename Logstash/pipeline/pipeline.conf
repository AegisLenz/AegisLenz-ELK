input {
    beats {
        port => 5045
        codec => json {
            charset => "UTF-8"
            target => "parsed_message"
        }
    }
}

filter {
    # parsed_message와 Records 필드가 있는 경우에만 처리
    if [parsed_message] and [parsed_message][Records] {
        # Records 배열을 개별 이벤트로 나눔
        split {
            field => "[parsed_message][Records]"
        }

        # 필요한 필드를 선택하고, 원하는 이름으로 매핑
        mutate {
            rename => {
                "[parsed_message][Records][sourceIPAddress]" => "source_ip"
                "[parsed_message][Records][userAgent]" => "user_agent"
                "[parsed_message][Records][eventName]" => "event_name"
                "[parsed_message][Records][eventType]" => "event_type"
                "[parsed_message][Records][eventSource]" => "event_source"
                "[parsed_message][Records][awsRegion]" => "aws_region"
                "[parsed_message][Records][errorCode]" => "error_code"
                "[parsed_message][Records][errorMessage]" => "error_message"
                "[parsed_message][Records][managementEvent]" => "management_event"
                "[parsed_message][Records][vpcEndpointId]" => "vpc_endpoint_id"
                "[parsed_message][Records][eventTime]" => "event_time"
            }
        }

        # event_time을 @timestamp로 변환
        date {
            match => ["event_time", "ISO8601"]
            target => "@timestamp"
        }

        # 불필요한 필드 삭제
        mutate {
            remove_field => ["parsed_message", "host", "agent"]
        }
    } else {
        drop { }
    }
}

output {
    elasticsearch {
        hosts => ["${ELASTIC_HOST}"]
        index => "cloudtrail-logs-%{+YYYY.MM.dd}"
        ssl_verification_mode => "none"
        ecs_compatibility => "v8"
    }
}
